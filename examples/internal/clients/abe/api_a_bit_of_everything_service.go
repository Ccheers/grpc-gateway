/*
 * A Bit of Everything
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0
 * Contact: none@example.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package abe

import (
	"context"
	"fmt"
	"github.com/antihax/optional"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// Linger please
var (
	_ context.Context
)

type ABitOfEverythingServiceApiService service

/*
ABitOfEverythingServiceApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param value

@return interface{}
*/
func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceCheckExternalNestedPathEnum(ctx context.Context, value string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v3/{value}:check"
	localVarPath = strings.Replace(localVarPath, "{"+"value"+"}", fmt.Sprintf("%v", value), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param value

@return interface{}
*/
func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceCheckExternalPathEnum(ctx context.Context, value string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v2/{value}:check"
	localVarPath = strings.Replace(localVarPath, "{"+"value"+"}", fmt.Sprintf("%v", value), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param singleNestedName name is nested field.
 * @param singleNestedAmount
 * @param singleNestedOk DeepEnum description.   - FALSE: FALSE is false.  - TRUE: TRUE is true.
 * @param uuid
 * @param floatValue Float value field
 * @param doubleValue
 * @param int64Value
 * @param uint64Value
 * @param int32Value
 * @param fixed64Value
 * @param fixed32Value
 * @param boolValue
 * @param stringValue
 * @param bytesValue
 * @param uint32Value
 * @param enumValue  - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param pathEnumValue
 * @param nestedPathEnumValue
 * @param sfixed32Value
 * @param sfixed64Value
 * @param sint32Value
 * @param sint64Value
 * @param repeatedStringValue
 * @param oneofEmpty
 * @param oneofString
 * @param mapValue map of numeric enum
 * @param mappedStringValue Map of string title  Map of string description.
 * @param mappedNestedValue
 * @param nonConventionalNameValue
 * @param timestampValue
 * @param repeatedEnumValue repeated enum value. it is comma-separated in query   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param repeatedEnumAnnotation Repeated numeric enum title  Repeated numeric enum description.   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param enumValueAnnotation Numeric enum title  Numeric enum description.   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param repeatedStringAnnotation Repeated string title  Repeated string description.
 * @param nestedAnnotationAmount
 * @param nestedAnnotationOk DeepEnum description.   - FALSE: FALSE is false.  - TRUE: TRUE is true.
 * @param int64OverrideType
 * @param requiredStringViaFieldBehaviorAnnotation mark a field as required in Open API definition
 * @param outputOnlyStringViaFieldBehaviorAnnotation mark a field as readonly in Open API definition
 * @param productId Test openapiv2 generation of repeated fields  Only digits are allowed.
 * @param optionalStringField Test openapiv2 generation of required fields with annotation and jsonschema to reproduce
 * @param requiredStringField1
 * @param requiredStringField2
 * @param requiredFieldBehaviorJsonNameCustom Test openapiv2 handling of required json_name fields
 * @param requiredFieldSchemaJsonNameCustom
 * @param trailingOnly Trailing only
 * @param trailingOnlyDot Trailing only dot.
 * @param trailingBoth Leading both  Trailing both.
 * @param trailingMultiline Leading multiline  This is an example of a multi-line comment.  Trailing multiline.
 * @param uuids Specify a custom format of repeated field items
 * @param optional nil or *ABitOfEverythingServiceCheckGetQueryParamsOpts - Optional Parameters:
     * @param "OptionalStringValue" (optional.String) -

@return ExamplepbABitOfEverything
*/

type ABitOfEverythingServiceCheckGetQueryParamsOpts struct {
	OptionalStringValue optional.String
}

func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceCheckGetQueryParams(ctx context.Context, singleNestedName string, singleNestedAmount int64, singleNestedOk string, uuid string, floatValue float32, doubleValue float64, int64Value string, uint64Value string, int32Value int32, fixed64Value string, fixed32Value int64, boolValue bool, stringValue string, bytesValue string, uint32Value int64, enumValue string, pathEnumValue string, nestedPathEnumValue string, sfixed32Value int32, sfixed64Value string, sint32Value int32, sint64Value string, repeatedStringValue []string, oneofEmpty map[string]string, oneofString string, mapValue interface{}, mappedStringValue string, mappedNestedValue interface{}, nonConventionalNameValue string, timestampValue time.Time, repeatedEnumValue []string, repeatedEnumAnnotation []string, enumValueAnnotation string, repeatedStringAnnotation []string, nestedAnnotationAmount int64, nestedAnnotationOk string, int64OverrideType int64, requiredStringViaFieldBehaviorAnnotation string, outputOnlyStringViaFieldBehaviorAnnotation string, productId []string, optionalStringField string, requiredStringField1 string, requiredStringField2 string, requiredFieldBehaviorJsonNameCustom string, requiredFieldSchemaJsonNameCustom string, trailingOnly string, trailingOnlyDot string, trailingBoth string, trailingMultiline string, uuids []string, localVarOptionals *ABitOfEverythingServiceCheckGetQueryParamsOpts) (ExamplepbABitOfEverything, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ExamplepbABitOfEverything
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/example/a_bit_of_everything/params/get/{singleNested.name}"
	localVarPath = strings.Replace(localVarPath, "{"+"singleNested.name"+"}", fmt.Sprintf("%v", singleNestedName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("singleNested.amount", parameterToString(singleNestedAmount, ""))
	localVarQueryParams.Add("singleNested.ok", parameterToString(singleNestedOk, ""))
	localVarQueryParams.Add("uuid", parameterToString(uuid, ""))
	localVarQueryParams.Add("floatValue", parameterToString(floatValue, ""))
	localVarQueryParams.Add("doubleValue", parameterToString(doubleValue, ""))
	localVarQueryParams.Add("int64Value", parameterToString(int64Value, ""))
	localVarQueryParams.Add("uint64Value", parameterToString(uint64Value, ""))
	localVarQueryParams.Add("int32Value", parameterToString(int32Value, ""))
	localVarQueryParams.Add("fixed64Value", parameterToString(fixed64Value, ""))
	localVarQueryParams.Add("fixed32Value", parameterToString(fixed32Value, ""))
	localVarQueryParams.Add("boolValue", parameterToString(boolValue, ""))
	localVarQueryParams.Add("stringValue", parameterToString(stringValue, ""))
	localVarQueryParams.Add("bytesValue", parameterToString(bytesValue, ""))
	localVarQueryParams.Add("uint32Value", parameterToString(uint32Value, ""))
	localVarQueryParams.Add("enumValue", parameterToString(enumValue, ""))
	localVarQueryParams.Add("pathEnumValue", parameterToString(pathEnumValue, ""))
	localVarQueryParams.Add("nestedPathEnumValue", parameterToString(nestedPathEnumValue, ""))
	localVarQueryParams.Add("sfixed32Value", parameterToString(sfixed32Value, ""))
	localVarQueryParams.Add("sfixed64Value", parameterToString(sfixed64Value, ""))
	localVarQueryParams.Add("sint32Value", parameterToString(sint32Value, ""))
	localVarQueryParams.Add("sint64Value", parameterToString(sint64Value, ""))
	localVarQueryParams.Add("repeatedStringValue", parameterToString(repeatedStringValue, "multi"))
	localVarQueryParams.Add("oneofEmpty", parameterToString(oneofEmpty, ""))
	localVarQueryParams.Add("oneofString", parameterToString(oneofString, ""))
	localVarQueryParams.Add("mapValue", parameterToString(mapValue, ""))
	localVarQueryParams.Add("mappedStringValue", parameterToString(mappedStringValue, ""))
	localVarQueryParams.Add("mappedNestedValue", parameterToString(mappedNestedValue, ""))
	localVarQueryParams.Add("nonConventionalNameValue", parameterToString(nonConventionalNameValue, ""))
	localVarQueryParams.Add("timestampValue", parameterToString(timestampValue, ""))
	localVarQueryParams.Add("repeatedEnumValue", parameterToString(repeatedEnumValue, "multi"))
	localVarQueryParams.Add("repeatedEnumAnnotation", parameterToString(repeatedEnumAnnotation, "multi"))
	localVarQueryParams.Add("enumValueAnnotation", parameterToString(enumValueAnnotation, ""))
	localVarQueryParams.Add("repeatedStringAnnotation", parameterToString(repeatedStringAnnotation, "multi"))
	localVarQueryParams.Add("nestedAnnotation.amount", parameterToString(nestedAnnotationAmount, ""))
	localVarQueryParams.Add("nestedAnnotation.ok", parameterToString(nestedAnnotationOk, ""))
	localVarQueryParams.Add("int64OverrideType", parameterToString(int64OverrideType, ""))
	localVarQueryParams.Add("requiredStringViaFieldBehaviorAnnotation", parameterToString(requiredStringViaFieldBehaviorAnnotation, ""))
	localVarQueryParams.Add("outputOnlyStringViaFieldBehaviorAnnotation", parameterToString(outputOnlyStringViaFieldBehaviorAnnotation, ""))
	if localVarOptionals != nil && localVarOptionals.OptionalStringValue.IsSet() {
		localVarQueryParams.Add("optionalStringValue", parameterToString(localVarOptionals.OptionalStringValue.Value(), ""))
	}
	localVarQueryParams.Add("productId", parameterToString(productId, "multi"))
	localVarQueryParams.Add("optionalStringField", parameterToString(optionalStringField, ""))
	localVarQueryParams.Add("requiredStringField1", parameterToString(requiredStringField1, ""))
	localVarQueryParams.Add("requiredStringField2", parameterToString(requiredStringField2, ""))
	localVarQueryParams.Add("required_field_behavior_json_name_custom", parameterToString(requiredFieldBehaviorJsonNameCustom, ""))
	localVarQueryParams.Add("required_field_schema_json_name_custom", parameterToString(requiredFieldSchemaJsonNameCustom, ""))
	localVarQueryParams.Add("trailingOnly", parameterToString(trailingOnly, ""))
	localVarQueryParams.Add("trailingOnlyDot", parameterToString(trailingOnlyDot, ""))
	localVarQueryParams.Add("trailingBoth", parameterToString(trailingBoth, ""))
	localVarQueryParams.Add("trailingMultiline", parameterToString(trailingMultiline, ""))
	localVarQueryParams.Add("uuids", parameterToString(uuids, "multi"))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ExamplepbABitOfEverything
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param singleNestedOk DeepEnum description.
 * @param singleNestedName name is nested field.
 * @param singleNestedAmount
 * @param uuid
 * @param floatValue Float value field
 * @param doubleValue
 * @param int64Value
 * @param uint64Value
 * @param int32Value
 * @param fixed64Value
 * @param fixed32Value
 * @param boolValue
 * @param stringValue
 * @param bytesValue
 * @param uint32Value
 * @param enumValue  - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param pathEnumValue
 * @param nestedPathEnumValue
 * @param sfixed32Value
 * @param sfixed64Value
 * @param sint32Value
 * @param sint64Value
 * @param repeatedStringValue
 * @param oneofEmpty
 * @param oneofString
 * @param mapValue map of numeric enum
 * @param mappedStringValue Map of string title  Map of string description.
 * @param mappedNestedValue
 * @param nonConventionalNameValue
 * @param timestampValue
 * @param repeatedEnumValue repeated enum value. it is comma-separated in query   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param repeatedEnumAnnotation Repeated numeric enum title  Repeated numeric enum description.   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param enumValueAnnotation Numeric enum title  Numeric enum description.   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param repeatedStringAnnotation Repeated string title  Repeated string description.
 * @param nestedAnnotationName name is nested field.
 * @param nestedAnnotationAmount
 * @param int64OverrideType
 * @param requiredStringViaFieldBehaviorAnnotation mark a field as required in Open API definition
 * @param outputOnlyStringViaFieldBehaviorAnnotation mark a field as readonly in Open API definition
 * @param productId Test openapiv2 generation of repeated fields  Only digits are allowed.
 * @param optionalStringField Test openapiv2 generation of required fields with annotation and jsonschema to reproduce
 * @param requiredStringField1
 * @param requiredStringField2
 * @param requiredFieldBehaviorJsonNameCustom Test openapiv2 handling of required json_name fields
 * @param requiredFieldSchemaJsonNameCustom
 * @param trailingOnly Trailing only
 * @param trailingOnlyDot Trailing only dot.
 * @param trailingBoth Leading both  Trailing both.
 * @param trailingMultiline Leading multiline  This is an example of a multi-line comment.  Trailing multiline.
 * @param uuids Specify a custom format of repeated field items
 * @param optional nil or *ABitOfEverythingServiceCheckNestedEnumGetQueryParamsOpts - Optional Parameters:
     * @param "OptionalStringValue" (optional.String) -

@return ExamplepbABitOfEverything
*/

type ABitOfEverythingServiceCheckNestedEnumGetQueryParamsOpts struct {
	OptionalStringValue optional.String
}

func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceCheckNestedEnumGetQueryParams(ctx context.Context, singleNestedOk string, singleNestedName string, singleNestedAmount int64, uuid string, floatValue float32, doubleValue float64, int64Value string, uint64Value string, int32Value int32, fixed64Value string, fixed32Value int64, boolValue bool, stringValue string, bytesValue string, uint32Value int64, enumValue string, pathEnumValue string, nestedPathEnumValue string, sfixed32Value int32, sfixed64Value string, sint32Value int32, sint64Value string, repeatedStringValue []string, oneofEmpty map[string]string, oneofString string, mapValue interface{}, mappedStringValue string, mappedNestedValue interface{}, nonConventionalNameValue string, timestampValue time.Time, repeatedEnumValue []string, repeatedEnumAnnotation []string, enumValueAnnotation string, repeatedStringAnnotation []string, nestedAnnotationName string, nestedAnnotationAmount int64, int64OverrideType int64, requiredStringViaFieldBehaviorAnnotation string, outputOnlyStringViaFieldBehaviorAnnotation string, productId []string, optionalStringField string, requiredStringField1 string, requiredStringField2 string, requiredFieldBehaviorJsonNameCustom string, requiredFieldSchemaJsonNameCustom string, trailingOnly string, trailingOnlyDot string, trailingBoth string, trailingMultiline string, uuids []string, localVarOptionals *ABitOfEverythingServiceCheckNestedEnumGetQueryParamsOpts) (ExamplepbABitOfEverything, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ExamplepbABitOfEverything
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/example/a_bit_of_everything/params/get/nested_enum/{singleNested.ok}"
	localVarPath = strings.Replace(localVarPath, "{"+"singleNested.ok"+"}", fmt.Sprintf("%v", singleNestedOk), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("singleNested.name", parameterToString(singleNestedName, ""))
	localVarQueryParams.Add("singleNested.amount", parameterToString(singleNestedAmount, ""))
	localVarQueryParams.Add("uuid", parameterToString(uuid, ""))
	localVarQueryParams.Add("floatValue", parameterToString(floatValue, ""))
	localVarQueryParams.Add("doubleValue", parameterToString(doubleValue, ""))
	localVarQueryParams.Add("int64Value", parameterToString(int64Value, ""))
	localVarQueryParams.Add("uint64Value", parameterToString(uint64Value, ""))
	localVarQueryParams.Add("int32Value", parameterToString(int32Value, ""))
	localVarQueryParams.Add("fixed64Value", parameterToString(fixed64Value, ""))
	localVarQueryParams.Add("fixed32Value", parameterToString(fixed32Value, ""))
	localVarQueryParams.Add("boolValue", parameterToString(boolValue, ""))
	localVarQueryParams.Add("stringValue", parameterToString(stringValue, ""))
	localVarQueryParams.Add("bytesValue", parameterToString(bytesValue, ""))
	localVarQueryParams.Add("uint32Value", parameterToString(uint32Value, ""))
	localVarQueryParams.Add("enumValue", parameterToString(enumValue, ""))
	localVarQueryParams.Add("pathEnumValue", parameterToString(pathEnumValue, ""))
	localVarQueryParams.Add("nestedPathEnumValue", parameterToString(nestedPathEnumValue, ""))
	localVarQueryParams.Add("sfixed32Value", parameterToString(sfixed32Value, ""))
	localVarQueryParams.Add("sfixed64Value", parameterToString(sfixed64Value, ""))
	localVarQueryParams.Add("sint32Value", parameterToString(sint32Value, ""))
	localVarQueryParams.Add("sint64Value", parameterToString(sint64Value, ""))
	localVarQueryParams.Add("repeatedStringValue", parameterToString(repeatedStringValue, "multi"))
	localVarQueryParams.Add("oneofEmpty", parameterToString(oneofEmpty, ""))
	localVarQueryParams.Add("oneofString", parameterToString(oneofString, ""))
	localVarQueryParams.Add("mapValue", parameterToString(mapValue, ""))
	localVarQueryParams.Add("mappedStringValue", parameterToString(mappedStringValue, ""))
	localVarQueryParams.Add("mappedNestedValue", parameterToString(mappedNestedValue, ""))
	localVarQueryParams.Add("nonConventionalNameValue", parameterToString(nonConventionalNameValue, ""))
	localVarQueryParams.Add("timestampValue", parameterToString(timestampValue, ""))
	localVarQueryParams.Add("repeatedEnumValue", parameterToString(repeatedEnumValue, "multi"))
	localVarQueryParams.Add("repeatedEnumAnnotation", parameterToString(repeatedEnumAnnotation, "multi"))
	localVarQueryParams.Add("enumValueAnnotation", parameterToString(enumValueAnnotation, ""))
	localVarQueryParams.Add("repeatedStringAnnotation", parameterToString(repeatedStringAnnotation, "multi"))
	localVarQueryParams.Add("nestedAnnotation.name", parameterToString(nestedAnnotationName, ""))
	localVarQueryParams.Add("nestedAnnotation.amount", parameterToString(nestedAnnotationAmount, ""))
	localVarQueryParams.Add("int64OverrideType", parameterToString(int64OverrideType, ""))
	localVarQueryParams.Add("requiredStringViaFieldBehaviorAnnotation", parameterToString(requiredStringViaFieldBehaviorAnnotation, ""))
	localVarQueryParams.Add("outputOnlyStringViaFieldBehaviorAnnotation", parameterToString(outputOnlyStringViaFieldBehaviorAnnotation, ""))
	if localVarOptionals != nil && localVarOptionals.OptionalStringValue.IsSet() {
		localVarQueryParams.Add("optionalStringValue", parameterToString(localVarOptionals.OptionalStringValue.Value(), ""))
	}
	localVarQueryParams.Add("productId", parameterToString(productId, "multi"))
	localVarQueryParams.Add("optionalStringField", parameterToString(optionalStringField, ""))
	localVarQueryParams.Add("requiredStringField1", parameterToString(requiredStringField1, ""))
	localVarQueryParams.Add("requiredStringField2", parameterToString(requiredStringField2, ""))
	localVarQueryParams.Add("required_field_behavior_json_name_custom", parameterToString(requiredFieldBehaviorJsonNameCustom, ""))
	localVarQueryParams.Add("required_field_schema_json_name_custom", parameterToString(requiredFieldSchemaJsonNameCustom, ""))
	localVarQueryParams.Add("trailingOnly", parameterToString(trailingOnly, ""))
	localVarQueryParams.Add("trailingOnlyDot", parameterToString(trailingOnlyDot, ""))
	localVarQueryParams.Add("trailingBoth", parameterToString(trailingBoth, ""))
	localVarQueryParams.Add("trailingMultiline", parameterToString(trailingMultiline, ""))
	localVarQueryParams.Add("uuids", parameterToString(uuids, "multi"))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ExamplepbABitOfEverything
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param stringValue
 * @param singleNested
 * @param uuid
 * @param floatValue Float value field
 * @param doubleValue
 * @param int64Value
 * @param uint64Value
 * @param int32Value
 * @param fixed64Value
 * @param fixed32Value
 * @param boolValue
 * @param bytesValue
 * @param uint32Value
 * @param enumValue  - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param pathEnumValue
 * @param nestedPathEnumValue
 * @param sfixed32Value
 * @param sfixed64Value
 * @param sint32Value
 * @param sint64Value
 * @param repeatedStringValue
 * @param oneofEmpty
 * @param oneofString
 * @param mapValue map of numeric enum
 * @param mappedStringValue Map of string title  Map of string description.
 * @param mappedNestedValue
 * @param nonConventionalNameValue
 * @param timestampValue
 * @param repeatedEnumValue repeated enum value. it is comma-separated in query   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param repeatedEnumAnnotation Repeated numeric enum title  Repeated numeric enum description.   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param enumValueAnnotation Numeric enum title  Numeric enum description.   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param repeatedStringAnnotation Repeated string title  Repeated string description.
 * @param nestedAnnotationName name is nested field.
 * @param nestedAnnotationAmount
 * @param nestedAnnotationOk DeepEnum description.   - FALSE: FALSE is false.  - TRUE: TRUE is true.
 * @param int64OverrideType
 * @param requiredStringViaFieldBehaviorAnnotation mark a field as required in Open API definition
 * @param outputOnlyStringViaFieldBehaviorAnnotation mark a field as readonly in Open API definition
 * @param productId Test openapiv2 generation of repeated fields  Only digits are allowed.
 * @param optionalStringField Test openapiv2 generation of required fields with annotation and jsonschema to reproduce
 * @param requiredStringField1
 * @param requiredStringField2
 * @param requiredFieldBehaviorJsonNameCustom Test openapiv2 handling of required json_name fields
 * @param requiredFieldSchemaJsonNameCustom
 * @param trailingOnly Trailing only
 * @param trailingOnlyDot Trailing only dot.
 * @param trailingBoth Leading both  Trailing both.
 * @param trailingMultiline Leading multiline  This is an example of a multi-line comment.  Trailing multiline.
 * @param uuids Specify a custom format of repeated field items
 * @param optional nil or *ABitOfEverythingServiceCheckPostQueryParamsOpts - Optional Parameters:
     * @param "OptionalStringValue" (optional.String) -

@return ExamplepbABitOfEverything
*/

type ABitOfEverythingServiceCheckPostQueryParamsOpts struct {
	OptionalStringValue optional.String
}

func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceCheckPostQueryParams(ctx context.Context, stringValue string, singleNested ABitOfEverythingNested, uuid string, floatValue float32, doubleValue float64, int64Value string, uint64Value string, int32Value int32, fixed64Value string, fixed32Value int64, boolValue bool, bytesValue string, uint32Value int64, enumValue string, pathEnumValue string, nestedPathEnumValue string, sfixed32Value int32, sfixed64Value string, sint32Value int32, sint64Value string, repeatedStringValue []string, oneofEmpty map[string]string, oneofString string, mapValue interface{}, mappedStringValue string, mappedNestedValue interface{}, nonConventionalNameValue string, timestampValue time.Time, repeatedEnumValue []string, repeatedEnumAnnotation []string, enumValueAnnotation string, repeatedStringAnnotation []string, nestedAnnotationName string, nestedAnnotationAmount int64, nestedAnnotationOk string, int64OverrideType int64, requiredStringViaFieldBehaviorAnnotation string, outputOnlyStringViaFieldBehaviorAnnotation string, productId []string, optionalStringField string, requiredStringField1 string, requiredStringField2 string, requiredFieldBehaviorJsonNameCustom string, requiredFieldSchemaJsonNameCustom string, trailingOnly string, trailingOnlyDot string, trailingBoth string, trailingMultiline string, uuids []string, localVarOptionals *ABitOfEverythingServiceCheckPostQueryParamsOpts) (ExamplepbABitOfEverything, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ExamplepbABitOfEverything
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/example/a_bit_of_everything/params/post/{stringValue}"
	localVarPath = strings.Replace(localVarPath, "{"+"stringValue"+"}", fmt.Sprintf("%v", stringValue), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("uuid", parameterToString(uuid, ""))
	localVarQueryParams.Add("floatValue", parameterToString(floatValue, ""))
	localVarQueryParams.Add("doubleValue", parameterToString(doubleValue, ""))
	localVarQueryParams.Add("int64Value", parameterToString(int64Value, ""))
	localVarQueryParams.Add("uint64Value", parameterToString(uint64Value, ""))
	localVarQueryParams.Add("int32Value", parameterToString(int32Value, ""))
	localVarQueryParams.Add("fixed64Value", parameterToString(fixed64Value, ""))
	localVarQueryParams.Add("fixed32Value", parameterToString(fixed32Value, ""))
	localVarQueryParams.Add("boolValue", parameterToString(boolValue, ""))
	localVarQueryParams.Add("bytesValue", parameterToString(bytesValue, ""))
	localVarQueryParams.Add("uint32Value", parameterToString(uint32Value, ""))
	localVarQueryParams.Add("enumValue", parameterToString(enumValue, ""))
	localVarQueryParams.Add("pathEnumValue", parameterToString(pathEnumValue, ""))
	localVarQueryParams.Add("nestedPathEnumValue", parameterToString(nestedPathEnumValue, ""))
	localVarQueryParams.Add("sfixed32Value", parameterToString(sfixed32Value, ""))
	localVarQueryParams.Add("sfixed64Value", parameterToString(sfixed64Value, ""))
	localVarQueryParams.Add("sint32Value", parameterToString(sint32Value, ""))
	localVarQueryParams.Add("sint64Value", parameterToString(sint64Value, ""))
	localVarQueryParams.Add("repeatedStringValue", parameterToString(repeatedStringValue, "multi"))
	localVarQueryParams.Add("oneofEmpty", parameterToString(oneofEmpty, ""))
	localVarQueryParams.Add("oneofString", parameterToString(oneofString, ""))
	localVarQueryParams.Add("mapValue", parameterToString(mapValue, ""))
	localVarQueryParams.Add("mappedStringValue", parameterToString(mappedStringValue, ""))
	localVarQueryParams.Add("mappedNestedValue", parameterToString(mappedNestedValue, ""))
	localVarQueryParams.Add("nonConventionalNameValue", parameterToString(nonConventionalNameValue, ""))
	localVarQueryParams.Add("timestampValue", parameterToString(timestampValue, ""))
	localVarQueryParams.Add("repeatedEnumValue", parameterToString(repeatedEnumValue, "multi"))
	localVarQueryParams.Add("repeatedEnumAnnotation", parameterToString(repeatedEnumAnnotation, "multi"))
	localVarQueryParams.Add("enumValueAnnotation", parameterToString(enumValueAnnotation, ""))
	localVarQueryParams.Add("repeatedStringAnnotation", parameterToString(repeatedStringAnnotation, "multi"))
	localVarQueryParams.Add("nestedAnnotation.name", parameterToString(nestedAnnotationName, ""))
	localVarQueryParams.Add("nestedAnnotation.amount", parameterToString(nestedAnnotationAmount, ""))
	localVarQueryParams.Add("nestedAnnotation.ok", parameterToString(nestedAnnotationOk, ""))
	localVarQueryParams.Add("int64OverrideType", parameterToString(int64OverrideType, ""))
	localVarQueryParams.Add("requiredStringViaFieldBehaviorAnnotation", parameterToString(requiredStringViaFieldBehaviorAnnotation, ""))
	localVarQueryParams.Add("outputOnlyStringViaFieldBehaviorAnnotation", parameterToString(outputOnlyStringViaFieldBehaviorAnnotation, ""))
	if localVarOptionals != nil && localVarOptionals.OptionalStringValue.IsSet() {
		localVarQueryParams.Add("optionalStringValue", parameterToString(localVarOptionals.OptionalStringValue.Value(), ""))
	}
	localVarQueryParams.Add("productId", parameterToString(productId, "multi"))
	localVarQueryParams.Add("optionalStringField", parameterToString(optionalStringField, ""))
	localVarQueryParams.Add("requiredStringField1", parameterToString(requiredStringField1, ""))
	localVarQueryParams.Add("requiredStringField2", parameterToString(requiredStringField2, ""))
	localVarQueryParams.Add("required_field_behavior_json_name_custom", parameterToString(requiredFieldBehaviorJsonNameCustom, ""))
	localVarQueryParams.Add("required_field_schema_json_name_custom", parameterToString(requiredFieldSchemaJsonNameCustom, ""))
	localVarQueryParams.Add("trailingOnly", parameterToString(trailingOnly, ""))
	localVarQueryParams.Add("trailingOnlyDot", parameterToString(trailingOnlyDot, ""))
	localVarQueryParams.Add("trailingBoth", parameterToString(trailingBoth, ""))
	localVarQueryParams.Add("trailingMultiline", parameterToString(trailingMultiline, ""))
	localVarQueryParams.Add("uuids", parameterToString(uuids, "multi"))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &singleNested
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ExamplepbABitOfEverything
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return ExamplepbCheckStatusResponse
*/
func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceCheckStatus(ctx context.Context) (ExamplepbCheckStatusResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ExamplepbCheckStatusResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/example/checkStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ExamplepbCheckStatusResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService Create a new ABitOfEverything
This API creates a new ABitOfEverything
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param floatValue Float value field
 * @param doubleValue
 * @param int64Value
 * @param uint64Value
 * @param int32Value
 * @param fixed64Value
 * @param fixed32Value
 * @param boolValue
 * @param stringValue
 * @param uint32Value
 * @param sfixed32Value
 * @param sfixed64Value
 * @param sint32Value
 * @param sint64Value
 * @param nonConventionalNameValue
 * @param enumValue
 * @param pathEnumValue
 * @param nestedPathEnumValue
 * @param enumValueAnnotation Numeric enum description.
 * @param singleNestedName name is nested field.
 * @param singleNestedAmount
 * @param singleNestedOk DeepEnum description.   - FALSE: FALSE is false.  - TRUE: TRUE is true.
 * @param uuid
 * @param bytesValue
 * @param repeatedStringValue
 * @param oneofEmpty
 * @param oneofString
 * @param mapValue map of numeric enum
 * @param mappedStringValue Map of string title  Map of string description.
 * @param mappedNestedValue
 * @param timestampValue
 * @param repeatedEnumValue repeated enum value. it is comma-separated in query   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param repeatedEnumAnnotation Repeated numeric enum title  Repeated numeric enum description.   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param repeatedStringAnnotation Repeated string title  Repeated string description.
 * @param nestedAnnotationName name is nested field.
 * @param nestedAnnotationAmount
 * @param nestedAnnotationOk DeepEnum description.   - FALSE: FALSE is false.  - TRUE: TRUE is true.
 * @param int64OverrideType
 * @param requiredStringViaFieldBehaviorAnnotation mark a field as required in Open API definition
 * @param outputOnlyStringViaFieldBehaviorAnnotation mark a field as readonly in Open API definition
 * @param productId Test openapiv2 generation of repeated fields  Only digits are allowed.
 * @param optionalStringField Test openapiv2 generation of required fields with annotation and jsonschema to reproduce
 * @param requiredStringField1
 * @param requiredStringField2
 * @param requiredFieldBehaviorJsonNameCustom Test openapiv2 handling of required json_name fields
 * @param requiredFieldSchemaJsonNameCustom
 * @param trailingOnly Trailing only
 * @param trailingOnlyDot Trailing only dot.
 * @param trailingBoth Leading both  Trailing both.
 * @param trailingMultiline Leading multiline  This is an example of a multi-line comment.  Trailing multiline.
 * @param uuids Specify a custom format of repeated field items
 * @param optional nil or *ABitOfEverythingServiceCreateOpts - Optional Parameters:
     * @param "OptionalStringValue" (optional.String) -

@return ExamplepbABitOfEverything
*/

type ABitOfEverythingServiceCreateOpts struct {
	OptionalStringValue optional.String
}

func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceCreate(ctx context.Context, floatValue float32, doubleValue float64, int64Value string, uint64Value string, int32Value int32, fixed64Value string, fixed32Value int64, boolValue bool, stringValue string, uint32Value int64, sfixed32Value int32, sfixed64Value string, sint32Value int32, sint64Value string, nonConventionalNameValue string, enumValue string, pathEnumValue string, nestedPathEnumValue string, enumValueAnnotation string, singleNestedName string, singleNestedAmount int64, singleNestedOk string, uuid string, bytesValue string, repeatedStringValue []string, oneofEmpty map[string]string, oneofString string, mapValue interface{}, mappedStringValue string, mappedNestedValue interface{}, timestampValue time.Time, repeatedEnumValue []string, repeatedEnumAnnotation []string, repeatedStringAnnotation []string, nestedAnnotationName string, nestedAnnotationAmount int64, nestedAnnotationOk string, int64OverrideType int64, requiredStringViaFieldBehaviorAnnotation string, outputOnlyStringViaFieldBehaviorAnnotation string, productId []string, optionalStringField string, requiredStringField1 string, requiredStringField2 string, requiredFieldBehaviorJsonNameCustom string, requiredFieldSchemaJsonNameCustom string, trailingOnly string, trailingOnlyDot string, trailingBoth string, trailingMultiline string, uuids []string, localVarOptionals *ABitOfEverythingServiceCreateOpts) (ExamplepbABitOfEverything, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ExamplepbABitOfEverything
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/example/a_bit_of_everything/{floatValue}/{doubleValue}/{int64Value}/separator/{uint64Value}/{int32Value}/{fixed64Value}/{fixed32Value}/{boolValue}/{stringValue}/{uint32Value}/{sfixed32Value}/{sfixed64Value}/{sint32Value}/{sint64Value}/{nonConventionalNameValue}/{enumValue}/{pathEnumValue}/{nestedPathEnumValue}/{enumValueAnnotation}"
	localVarPath = strings.Replace(localVarPath, "{"+"floatValue"+"}", fmt.Sprintf("%v", floatValue), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"doubleValue"+"}", fmt.Sprintf("%v", doubleValue), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"int64Value"+"}", fmt.Sprintf("%v", int64Value), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uint64Value"+"}", fmt.Sprintf("%v", uint64Value), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"int32Value"+"}", fmt.Sprintf("%v", int32Value), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fixed64Value"+"}", fmt.Sprintf("%v", fixed64Value), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fixed32Value"+"}", fmt.Sprintf("%v", fixed32Value), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"boolValue"+"}", fmt.Sprintf("%v", boolValue), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stringValue"+"}", fmt.Sprintf("%v", stringValue), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uint32Value"+"}", fmt.Sprintf("%v", uint32Value), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sfixed32Value"+"}", fmt.Sprintf("%v", sfixed32Value), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sfixed64Value"+"}", fmt.Sprintf("%v", sfixed64Value), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sint32Value"+"}", fmt.Sprintf("%v", sint32Value), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sint64Value"+"}", fmt.Sprintf("%v", sint64Value), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nonConventionalNameValue"+"}", fmt.Sprintf("%v", nonConventionalNameValue), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"enumValue"+"}", fmt.Sprintf("%v", enumValue), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pathEnumValue"+"}", fmt.Sprintf("%v", pathEnumValue), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nestedPathEnumValue"+"}", fmt.Sprintf("%v", nestedPathEnumValue), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"enumValueAnnotation"+"}", fmt.Sprintf("%v", enumValueAnnotation), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("singleNested.name", parameterToString(singleNestedName, ""))
	localVarQueryParams.Add("singleNested.amount", parameterToString(singleNestedAmount, ""))
	localVarQueryParams.Add("singleNested.ok", parameterToString(singleNestedOk, ""))
	localVarQueryParams.Add("uuid", parameterToString(uuid, ""))
	localVarQueryParams.Add("bytesValue", parameterToString(bytesValue, ""))
	localVarQueryParams.Add("repeatedStringValue", parameterToString(repeatedStringValue, "multi"))
	localVarQueryParams.Add("oneofEmpty", parameterToString(oneofEmpty, ""))
	localVarQueryParams.Add("oneofString", parameterToString(oneofString, ""))
	localVarQueryParams.Add("mapValue", parameterToString(mapValue, ""))
	localVarQueryParams.Add("mappedStringValue", parameterToString(mappedStringValue, ""))
	localVarQueryParams.Add("mappedNestedValue", parameterToString(mappedNestedValue, ""))
	localVarQueryParams.Add("timestampValue", parameterToString(timestampValue, ""))
	localVarQueryParams.Add("repeatedEnumValue", parameterToString(repeatedEnumValue, "multi"))
	localVarQueryParams.Add("repeatedEnumAnnotation", parameterToString(repeatedEnumAnnotation, "multi"))
	localVarQueryParams.Add("repeatedStringAnnotation", parameterToString(repeatedStringAnnotation, "multi"))
	localVarQueryParams.Add("nestedAnnotation.name", parameterToString(nestedAnnotationName, ""))
	localVarQueryParams.Add("nestedAnnotation.amount", parameterToString(nestedAnnotationAmount, ""))
	localVarQueryParams.Add("nestedAnnotation.ok", parameterToString(nestedAnnotationOk, ""))
	localVarQueryParams.Add("int64OverrideType", parameterToString(int64OverrideType, ""))
	localVarQueryParams.Add("requiredStringViaFieldBehaviorAnnotation", parameterToString(requiredStringViaFieldBehaviorAnnotation, ""))
	localVarQueryParams.Add("outputOnlyStringViaFieldBehaviorAnnotation", parameterToString(outputOnlyStringViaFieldBehaviorAnnotation, ""))
	if localVarOptionals != nil && localVarOptionals.OptionalStringValue.IsSet() {
		localVarQueryParams.Add("optionalStringValue", parameterToString(localVarOptionals.OptionalStringValue.Value(), ""))
	}
	localVarQueryParams.Add("productId", parameterToString(productId, "multi"))
	localVarQueryParams.Add("optionalStringField", parameterToString(optionalStringField, ""))
	localVarQueryParams.Add("requiredStringField1", parameterToString(requiredStringField1, ""))
	localVarQueryParams.Add("requiredStringField2", parameterToString(requiredStringField2, ""))
	localVarQueryParams.Add("required_field_behavior_json_name_custom", parameterToString(requiredFieldBehaviorJsonNameCustom, ""))
	localVarQueryParams.Add("required_field_schema_json_name_custom", parameterToString(requiredFieldSchemaJsonNameCustom, ""))
	localVarQueryParams.Add("trailingOnly", parameterToString(trailingOnly, ""))
	localVarQueryParams.Add("trailingOnlyDot", parameterToString(trailingOnlyDot, ""))
	localVarQueryParams.Add("trailingBoth", parameterToString(trailingBoth, ""))
	localVarQueryParams.Add("trailingMultiline", parameterToString(trailingMultiline, ""))
	localVarQueryParams.Add("uuids", parameterToString(uuids, "multi"))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ExamplepbABitOfEverything
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body Intentionally complicated message type to cover many features of Protobuf.

@return ExamplepbABitOfEverything
*/
func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceCreateBody(ctx context.Context, body ExamplepbABitOfEverything) (ExamplepbABitOfEverything, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ExamplepbABitOfEverything
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/example/a_bit_of_everything"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ExamplepbABitOfEverything
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService Create a book.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param parent The publisher in which to create the book.  Format: &#x60;publishers/{publisher}&#x60;  Example: &#x60;publishers/1257894000000000000&#x60;
  - @param book The book to create.
  - @param bookId The ID to use for the book.  This must start with an alphanumeric character.

@return ExamplepbBook
*/
func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceCreateBook(ctx context.Context, parent string, book ExamplepbBook, bookId string) (ExamplepbBook, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ExamplepbBook
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/{parent}/books"
	localVarPath = strings.Replace(localVarPath, "{"+"parent"+"}", fmt.Sprintf("%v", parent), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("bookId", parameterToString(bookId, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &book
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ExamplepbBook
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuidName
 * @param singleNestedName name is nested field.
 * @param singleNestedAmount
 * @param singleNestedOk DeepEnum description.   - FALSE: FALSE is false.  - TRUE: TRUE is true.
 * @param floatValue Float value field
 * @param doubleValue
 * @param int64Value
 * @param uint64Value
 * @param int32Value
 * @param fixed64Value
 * @param fixed32Value
 * @param boolValue
 * @param stringValue
 * @param bytesValue
 * @param uint32Value
 * @param enumValue  - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param pathEnumValue
 * @param nestedPathEnumValue
 * @param sfixed32Value
 * @param sfixed64Value
 * @param sint32Value
 * @param sint64Value
 * @param repeatedStringValue
 * @param oneofEmpty
 * @param oneofString
 * @param mapValue map of numeric enum
 * @param mappedStringValue Map of string title  Map of string description.
 * @param mappedNestedValue
 * @param nonConventionalNameValue
 * @param timestampValue
 * @param repeatedEnumValue repeated enum value. it is comma-separated in query   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param repeatedEnumAnnotation Repeated numeric enum title  Repeated numeric enum description.   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param enumValueAnnotation Numeric enum title  Numeric enum description.   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param repeatedStringAnnotation Repeated string title  Repeated string description.
 * @param nestedAnnotationName name is nested field.
 * @param nestedAnnotationAmount
 * @param nestedAnnotationOk DeepEnum description.   - FALSE: FALSE is false.  - TRUE: TRUE is true.
 * @param int64OverrideType
 * @param requiredStringViaFieldBehaviorAnnotation mark a field as required in Open API definition
 * @param outputOnlyStringViaFieldBehaviorAnnotation mark a field as readonly in Open API definition
 * @param productId Test openapiv2 generation of repeated fields  Only digits are allowed.
 * @param optionalStringField Test openapiv2 generation of required fields with annotation and jsonschema to reproduce
 * @param requiredStringField1
 * @param requiredStringField2
 * @param requiredFieldBehaviorJsonNameCustom Test openapiv2 handling of required json_name fields
 * @param requiredFieldSchemaJsonNameCustom
 * @param trailingOnly Trailing only
 * @param trailingOnlyDot Trailing only dot.
 * @param trailingBoth Leading both  Trailing both.
 * @param trailingMultiline Leading multiline  This is an example of a multi-line comment.  Trailing multiline.
 * @param uuids Specify a custom format of repeated field items
 * @param optional nil or *ABitOfEverythingServiceCustomOpts - Optional Parameters:
     * @param "OptionalStringValue" (optional.String) -

@return ExamplepbABitOfEverything
*/

type ABitOfEverythingServiceCustomOpts struct {
	OptionalStringValue optional.String
}

func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceCustom(ctx context.Context, uuidName string, singleNestedName string, singleNestedAmount int64, singleNestedOk string, floatValue float32, doubleValue float64, int64Value string, uint64Value string, int32Value int32, fixed64Value string, fixed32Value int64, boolValue bool, stringValue string, bytesValue string, uint32Value int64, enumValue string, pathEnumValue string, nestedPathEnumValue string, sfixed32Value int32, sfixed64Value string, sint32Value int32, sint64Value string, repeatedStringValue []string, oneofEmpty map[string]string, oneofString string, mapValue interface{}, mappedStringValue string, mappedNestedValue interface{}, nonConventionalNameValue string, timestampValue time.Time, repeatedEnumValue []string, repeatedEnumAnnotation []string, enumValueAnnotation string, repeatedStringAnnotation []string, nestedAnnotationName string, nestedAnnotationAmount int64, nestedAnnotationOk string, int64OverrideType int64, requiredStringViaFieldBehaviorAnnotation string, outputOnlyStringViaFieldBehaviorAnnotation string, productId []string, optionalStringField string, requiredStringField1 string, requiredStringField2 string, requiredFieldBehaviorJsonNameCustom string, requiredFieldSchemaJsonNameCustom string, trailingOnly string, trailingOnlyDot string, trailingBoth string, trailingMultiline string, uuids []string, localVarOptionals *ABitOfEverythingServiceCustomOpts) (ExamplepbABitOfEverything, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ExamplepbABitOfEverything
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/example/a_bit_of_everything/{uuidName}:custom"
	localVarPath = strings.Replace(localVarPath, "{"+"uuidName"+"}", fmt.Sprintf("%v", uuidName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("singleNested.name", parameterToString(singleNestedName, ""))
	localVarQueryParams.Add("singleNested.amount", parameterToString(singleNestedAmount, ""))
	localVarQueryParams.Add("singleNested.ok", parameterToString(singleNestedOk, ""))
	localVarQueryParams.Add("floatValue", parameterToString(floatValue, ""))
	localVarQueryParams.Add("doubleValue", parameterToString(doubleValue, ""))
	localVarQueryParams.Add("int64Value", parameterToString(int64Value, ""))
	localVarQueryParams.Add("uint64Value", parameterToString(uint64Value, ""))
	localVarQueryParams.Add("int32Value", parameterToString(int32Value, ""))
	localVarQueryParams.Add("fixed64Value", parameterToString(fixed64Value, ""))
	localVarQueryParams.Add("fixed32Value", parameterToString(fixed32Value, ""))
	localVarQueryParams.Add("boolValue", parameterToString(boolValue, ""))
	localVarQueryParams.Add("stringValue", parameterToString(stringValue, ""))
	localVarQueryParams.Add("bytesValue", parameterToString(bytesValue, ""))
	localVarQueryParams.Add("uint32Value", parameterToString(uint32Value, ""))
	localVarQueryParams.Add("enumValue", parameterToString(enumValue, ""))
	localVarQueryParams.Add("pathEnumValue", parameterToString(pathEnumValue, ""))
	localVarQueryParams.Add("nestedPathEnumValue", parameterToString(nestedPathEnumValue, ""))
	localVarQueryParams.Add("sfixed32Value", parameterToString(sfixed32Value, ""))
	localVarQueryParams.Add("sfixed64Value", parameterToString(sfixed64Value, ""))
	localVarQueryParams.Add("sint32Value", parameterToString(sint32Value, ""))
	localVarQueryParams.Add("sint64Value", parameterToString(sint64Value, ""))
	localVarQueryParams.Add("repeatedStringValue", parameterToString(repeatedStringValue, "multi"))
	localVarQueryParams.Add("oneofEmpty", parameterToString(oneofEmpty, ""))
	localVarQueryParams.Add("oneofString", parameterToString(oneofString, ""))
	localVarQueryParams.Add("mapValue", parameterToString(mapValue, ""))
	localVarQueryParams.Add("mappedStringValue", parameterToString(mappedStringValue, ""))
	localVarQueryParams.Add("mappedNestedValue", parameterToString(mappedNestedValue, ""))
	localVarQueryParams.Add("nonConventionalNameValue", parameterToString(nonConventionalNameValue, ""))
	localVarQueryParams.Add("timestampValue", parameterToString(timestampValue, ""))
	localVarQueryParams.Add("repeatedEnumValue", parameterToString(repeatedEnumValue, "multi"))
	localVarQueryParams.Add("repeatedEnumAnnotation", parameterToString(repeatedEnumAnnotation, "multi"))
	localVarQueryParams.Add("enumValueAnnotation", parameterToString(enumValueAnnotation, ""))
	localVarQueryParams.Add("repeatedStringAnnotation", parameterToString(repeatedStringAnnotation, "multi"))
	localVarQueryParams.Add("nestedAnnotation.name", parameterToString(nestedAnnotationName, ""))
	localVarQueryParams.Add("nestedAnnotation.amount", parameterToString(nestedAnnotationAmount, ""))
	localVarQueryParams.Add("nestedAnnotation.ok", parameterToString(nestedAnnotationOk, ""))
	localVarQueryParams.Add("int64OverrideType", parameterToString(int64OverrideType, ""))
	localVarQueryParams.Add("requiredStringViaFieldBehaviorAnnotation", parameterToString(requiredStringViaFieldBehaviorAnnotation, ""))
	localVarQueryParams.Add("outputOnlyStringViaFieldBehaviorAnnotation", parameterToString(outputOnlyStringViaFieldBehaviorAnnotation, ""))
	if localVarOptionals != nil && localVarOptionals.OptionalStringValue.IsSet() {
		localVarQueryParams.Add("optionalStringValue", parameterToString(localVarOptionals.OptionalStringValue.Value(), ""))
	}
	localVarQueryParams.Add("productId", parameterToString(productId, "multi"))
	localVarQueryParams.Add("optionalStringField", parameterToString(optionalStringField, ""))
	localVarQueryParams.Add("requiredStringField1", parameterToString(requiredStringField1, ""))
	localVarQueryParams.Add("requiredStringField2", parameterToString(requiredStringField2, ""))
	localVarQueryParams.Add("required_field_behavior_json_name_custom", parameterToString(requiredFieldBehaviorJsonNameCustom, ""))
	localVarQueryParams.Add("required_field_schema_json_name_custom", parameterToString(requiredFieldSchemaJsonNameCustom, ""))
	localVarQueryParams.Add("trailingOnly", parameterToString(trailingOnly, ""))
	localVarQueryParams.Add("trailingOnlyDot", parameterToString(trailingOnlyDot, ""))
	localVarQueryParams.Add("trailingBoth", parameterToString(trailingBoth, ""))
	localVarQueryParams.Add("trailingMultiline", parameterToString(trailingMultiline, ""))
	localVarQueryParams.Add("uuids", parameterToString(uuids, "multi"))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ExamplepbABitOfEverything
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuidName
 * @param singleNestedName name is nested field.
 * @param singleNestedAmount
 * @param singleNestedOk DeepEnum description.   - FALSE: FALSE is false.  - TRUE: TRUE is true.
 * @param floatValue Float value field
 * @param doubleValue
 * @param int64Value
 * @param uint64Value
 * @param int32Value
 * @param fixed64Value
 * @param fixed32Value
 * @param boolValue
 * @param stringValue
 * @param bytesValue
 * @param uint32Value
 * @param enumValue  - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param pathEnumValue
 * @param nestedPathEnumValue
 * @param sfixed32Value
 * @param sfixed64Value
 * @param sint32Value
 * @param sint64Value
 * @param repeatedStringValue
 * @param oneofEmpty
 * @param oneofString
 * @param mapValue map of numeric enum
 * @param mappedStringValue Map of string title  Map of string description.
 * @param mappedNestedValue
 * @param nonConventionalNameValue
 * @param timestampValue
 * @param repeatedEnumValue repeated enum value. it is comma-separated in query   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param repeatedEnumAnnotation Repeated numeric enum title  Repeated numeric enum description.   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param enumValueAnnotation Numeric enum title  Numeric enum description.   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param repeatedStringAnnotation Repeated string title  Repeated string description.
 * @param nestedAnnotationName name is nested field.
 * @param nestedAnnotationAmount
 * @param nestedAnnotationOk DeepEnum description.   - FALSE: FALSE is false.  - TRUE: TRUE is true.
 * @param int64OverrideType
 * @param requiredStringViaFieldBehaviorAnnotation mark a field as required in Open API definition
 * @param outputOnlyStringViaFieldBehaviorAnnotation mark a field as readonly in Open API definition
 * @param productId Test openapiv2 generation of repeated fields  Only digits are allowed.
 * @param optionalStringField Test openapiv2 generation of required fields with annotation and jsonschema to reproduce
 * @param requiredStringField1
 * @param requiredStringField2
 * @param requiredFieldBehaviorJsonNameCustom Test openapiv2 handling of required json_name fields
 * @param requiredFieldSchemaJsonNameCustom
 * @param trailingOnly Trailing only
 * @param trailingOnlyDot Trailing only dot.
 * @param trailingBoth Leading both  Trailing both.
 * @param trailingMultiline Leading multiline  This is an example of a multi-line comment.  Trailing multiline.
 * @param uuids Specify a custom format of repeated field items
 * @param optional nil or *ABitOfEverythingServiceCustomOptionsRequestOpts - Optional Parameters:
     * @param "OptionalStringValue" (optional.String) -

@return interface{}
*/

type ABitOfEverythingServiceCustomOptionsRequestOpts struct {
	OptionalStringValue optional.String
}

func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceCustomOptionsRequest(ctx context.Context, uuidName string, singleNestedName string, singleNestedAmount int64, singleNestedOk string, floatValue float32, doubleValue float64, int64Value string, uint64Value string, int32Value int32, fixed64Value string, fixed32Value int64, boolValue bool, stringValue string, bytesValue string, uint32Value int64, enumValue string, pathEnumValue string, nestedPathEnumValue string, sfixed32Value int32, sfixed64Value string, sint32Value int32, sint64Value string, repeatedStringValue []string, oneofEmpty map[string]string, oneofString string, mapValue interface{}, mappedStringValue string, mappedNestedValue interface{}, nonConventionalNameValue string, timestampValue time.Time, repeatedEnumValue []string, repeatedEnumAnnotation []string, enumValueAnnotation string, repeatedStringAnnotation []string, nestedAnnotationName string, nestedAnnotationAmount int64, nestedAnnotationOk string, int64OverrideType int64, requiredStringViaFieldBehaviorAnnotation string, outputOnlyStringViaFieldBehaviorAnnotation string, productId []string, optionalStringField string, requiredStringField1 string, requiredStringField2 string, requiredFieldBehaviorJsonNameCustom string, requiredFieldSchemaJsonNameCustom string, trailingOnly string, trailingOnlyDot string, trailingBoth string, trailingMultiline string, uuids []string, localVarOptionals *ABitOfEverythingServiceCustomOptionsRequestOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Options")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/example/a_bit_of_everything/{uuidName}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuidName"+"}", fmt.Sprintf("%v", uuidName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("singleNested.name", parameterToString(singleNestedName, ""))
	localVarQueryParams.Add("singleNested.amount", parameterToString(singleNestedAmount, ""))
	localVarQueryParams.Add("singleNested.ok", parameterToString(singleNestedOk, ""))
	localVarQueryParams.Add("floatValue", parameterToString(floatValue, ""))
	localVarQueryParams.Add("doubleValue", parameterToString(doubleValue, ""))
	localVarQueryParams.Add("int64Value", parameterToString(int64Value, ""))
	localVarQueryParams.Add("uint64Value", parameterToString(uint64Value, ""))
	localVarQueryParams.Add("int32Value", parameterToString(int32Value, ""))
	localVarQueryParams.Add("fixed64Value", parameterToString(fixed64Value, ""))
	localVarQueryParams.Add("fixed32Value", parameterToString(fixed32Value, ""))
	localVarQueryParams.Add("boolValue", parameterToString(boolValue, ""))
	localVarQueryParams.Add("stringValue", parameterToString(stringValue, ""))
	localVarQueryParams.Add("bytesValue", parameterToString(bytesValue, ""))
	localVarQueryParams.Add("uint32Value", parameterToString(uint32Value, ""))
	localVarQueryParams.Add("enumValue", parameterToString(enumValue, ""))
	localVarQueryParams.Add("pathEnumValue", parameterToString(pathEnumValue, ""))
	localVarQueryParams.Add("nestedPathEnumValue", parameterToString(nestedPathEnumValue, ""))
	localVarQueryParams.Add("sfixed32Value", parameterToString(sfixed32Value, ""))
	localVarQueryParams.Add("sfixed64Value", parameterToString(sfixed64Value, ""))
	localVarQueryParams.Add("sint32Value", parameterToString(sint32Value, ""))
	localVarQueryParams.Add("sint64Value", parameterToString(sint64Value, ""))
	localVarQueryParams.Add("repeatedStringValue", parameterToString(repeatedStringValue, "multi"))
	localVarQueryParams.Add("oneofEmpty", parameterToString(oneofEmpty, ""))
	localVarQueryParams.Add("oneofString", parameterToString(oneofString, ""))
	localVarQueryParams.Add("mapValue", parameterToString(mapValue, ""))
	localVarQueryParams.Add("mappedStringValue", parameterToString(mappedStringValue, ""))
	localVarQueryParams.Add("mappedNestedValue", parameterToString(mappedNestedValue, ""))
	localVarQueryParams.Add("nonConventionalNameValue", parameterToString(nonConventionalNameValue, ""))
	localVarQueryParams.Add("timestampValue", parameterToString(timestampValue, ""))
	localVarQueryParams.Add("repeatedEnumValue", parameterToString(repeatedEnumValue, "multi"))
	localVarQueryParams.Add("repeatedEnumAnnotation", parameterToString(repeatedEnumAnnotation, "multi"))
	localVarQueryParams.Add("enumValueAnnotation", parameterToString(enumValueAnnotation, ""))
	localVarQueryParams.Add("repeatedStringAnnotation", parameterToString(repeatedStringAnnotation, "multi"))
	localVarQueryParams.Add("nestedAnnotation.name", parameterToString(nestedAnnotationName, ""))
	localVarQueryParams.Add("nestedAnnotation.amount", parameterToString(nestedAnnotationAmount, ""))
	localVarQueryParams.Add("nestedAnnotation.ok", parameterToString(nestedAnnotationOk, ""))
	localVarQueryParams.Add("int64OverrideType", parameterToString(int64OverrideType, ""))
	localVarQueryParams.Add("requiredStringViaFieldBehaviorAnnotation", parameterToString(requiredStringViaFieldBehaviorAnnotation, ""))
	localVarQueryParams.Add("outputOnlyStringViaFieldBehaviorAnnotation", parameterToString(outputOnlyStringViaFieldBehaviorAnnotation, ""))
	if localVarOptionals != nil && localVarOptionals.OptionalStringValue.IsSet() {
		localVarQueryParams.Add("optionalStringValue", parameterToString(localVarOptionals.OptionalStringValue.Value(), ""))
	}
	localVarQueryParams.Add("productId", parameterToString(productId, "multi"))
	localVarQueryParams.Add("optionalStringField", parameterToString(optionalStringField, ""))
	localVarQueryParams.Add("requiredStringField1", parameterToString(requiredStringField1, ""))
	localVarQueryParams.Add("requiredStringField2", parameterToString(requiredStringField2, ""))
	localVarQueryParams.Add("required_field_behavior_json_name_custom", parameterToString(requiredFieldBehaviorJsonNameCustom, ""))
	localVarQueryParams.Add("required_field_schema_json_name_custom", parameterToString(requiredFieldSchemaJsonNameCustom, ""))
	localVarQueryParams.Add("trailingOnly", parameterToString(trailingOnly, ""))
	localVarQueryParams.Add("trailingOnlyDot", parameterToString(trailingOnlyDot, ""))
	localVarQueryParams.Add("trailingBoth", parameterToString(trailingBoth, ""))
	localVarQueryParams.Add("trailingMultiline", parameterToString(trailingMultiline, ""))
	localVarQueryParams.Add("uuids", parameterToString(uuids, "multi"))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param singleNestedName name is nested field.
  - @param body

@return ExamplepbABitOfEverything
*/
func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceDeepPathEcho(ctx context.Context, singleNestedName string, body ABitOfEverythingServiceDeepPathEchoBody) (ExamplepbABitOfEverything, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ExamplepbABitOfEverything
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/example/deep_path/{singleNested.name}"
	localVarPath = strings.Replace(localVarPath, "{"+"singleNested.name"+"}", fmt.Sprintf("%v", singleNestedName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ExamplepbABitOfEverything
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuidName
 * @param singleNestedName name is nested field.
 * @param singleNestedAmount
 * @param singleNestedOk DeepEnum description.   - FALSE: FALSE is false.  - TRUE: TRUE is true.
 * @param floatValue Float value field
 * @param doubleValue
 * @param int64Value
 * @param uint64Value
 * @param int32Value
 * @param fixed64Value
 * @param fixed32Value
 * @param boolValue
 * @param stringValue
 * @param bytesValue
 * @param uint32Value
 * @param enumValue  - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param pathEnumValue
 * @param nestedPathEnumValue
 * @param sfixed32Value
 * @param sfixed64Value
 * @param sint32Value
 * @param sint64Value
 * @param repeatedStringValue
 * @param oneofEmpty
 * @param oneofString
 * @param mapValue map of numeric enum
 * @param mappedStringValue Map of string title  Map of string description.
 * @param mappedNestedValue
 * @param nonConventionalNameValue
 * @param timestampValue
 * @param repeatedEnumValue repeated enum value. it is comma-separated in query   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param repeatedEnumAnnotation Repeated numeric enum title  Repeated numeric enum description.   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param enumValueAnnotation Numeric enum title  Numeric enum description.   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param repeatedStringAnnotation Repeated string title  Repeated string description.
 * @param nestedAnnotationName name is nested field.
 * @param nestedAnnotationAmount
 * @param nestedAnnotationOk DeepEnum description.   - FALSE: FALSE is false.  - TRUE: TRUE is true.
 * @param int64OverrideType
 * @param requiredStringViaFieldBehaviorAnnotation mark a field as required in Open API definition
 * @param outputOnlyStringViaFieldBehaviorAnnotation mark a field as readonly in Open API definition
 * @param productId Test openapiv2 generation of repeated fields  Only digits are allowed.
 * @param optionalStringField Test openapiv2 generation of required fields with annotation and jsonschema to reproduce
 * @param requiredStringField1
 * @param requiredStringField2
 * @param requiredFieldBehaviorJsonNameCustom Test openapiv2 handling of required json_name fields
 * @param requiredFieldSchemaJsonNameCustom
 * @param trailingOnly Trailing only
 * @param trailingOnlyDot Trailing only dot.
 * @param trailingBoth Leading both  Trailing both.
 * @param trailingMultiline Leading multiline  This is an example of a multi-line comment.  Trailing multiline.
 * @param uuids Specify a custom format of repeated field items
 * @param optional nil or *ABitOfEverythingServiceDoubleColonOpts - Optional Parameters:
     * @param "OptionalStringValue" (optional.String) -

@return ExamplepbABitOfEverything
*/

type ABitOfEverythingServiceDoubleColonOpts struct {
	OptionalStringValue optional.String
}

func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceDoubleColon(ctx context.Context, uuidName string, singleNestedName string, singleNestedAmount int64, singleNestedOk string, floatValue float32, doubleValue float64, int64Value string, uint64Value string, int32Value int32, fixed64Value string, fixed32Value int64, boolValue bool, stringValue string, bytesValue string, uint32Value int64, enumValue string, pathEnumValue string, nestedPathEnumValue string, sfixed32Value int32, sfixed64Value string, sint32Value int32, sint64Value string, repeatedStringValue []string, oneofEmpty map[string]string, oneofString string, mapValue interface{}, mappedStringValue string, mappedNestedValue interface{}, nonConventionalNameValue string, timestampValue time.Time, repeatedEnumValue []string, repeatedEnumAnnotation []string, enumValueAnnotation string, repeatedStringAnnotation []string, nestedAnnotationName string, nestedAnnotationAmount int64, nestedAnnotationOk string, int64OverrideType int64, requiredStringViaFieldBehaviorAnnotation string, outputOnlyStringViaFieldBehaviorAnnotation string, productId []string, optionalStringField string, requiredStringField1 string, requiredStringField2 string, requiredFieldBehaviorJsonNameCustom string, requiredFieldSchemaJsonNameCustom string, trailingOnly string, trailingOnlyDot string, trailingBoth string, trailingMultiline string, uuids []string, localVarOptionals *ABitOfEverythingServiceDoubleColonOpts) (ExamplepbABitOfEverything, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ExamplepbABitOfEverything
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/example/a_bit_of_everything/{uuidName}:custom:custom"
	localVarPath = strings.Replace(localVarPath, "{"+"uuidName"+"}", fmt.Sprintf("%v", uuidName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("singleNested.name", parameterToString(singleNestedName, ""))
	localVarQueryParams.Add("singleNested.amount", parameterToString(singleNestedAmount, ""))
	localVarQueryParams.Add("singleNested.ok", parameterToString(singleNestedOk, ""))
	localVarQueryParams.Add("floatValue", parameterToString(floatValue, ""))
	localVarQueryParams.Add("doubleValue", parameterToString(doubleValue, ""))
	localVarQueryParams.Add("int64Value", parameterToString(int64Value, ""))
	localVarQueryParams.Add("uint64Value", parameterToString(uint64Value, ""))
	localVarQueryParams.Add("int32Value", parameterToString(int32Value, ""))
	localVarQueryParams.Add("fixed64Value", parameterToString(fixed64Value, ""))
	localVarQueryParams.Add("fixed32Value", parameterToString(fixed32Value, ""))
	localVarQueryParams.Add("boolValue", parameterToString(boolValue, ""))
	localVarQueryParams.Add("stringValue", parameterToString(stringValue, ""))
	localVarQueryParams.Add("bytesValue", parameterToString(bytesValue, ""))
	localVarQueryParams.Add("uint32Value", parameterToString(uint32Value, ""))
	localVarQueryParams.Add("enumValue", parameterToString(enumValue, ""))
	localVarQueryParams.Add("pathEnumValue", parameterToString(pathEnumValue, ""))
	localVarQueryParams.Add("nestedPathEnumValue", parameterToString(nestedPathEnumValue, ""))
	localVarQueryParams.Add("sfixed32Value", parameterToString(sfixed32Value, ""))
	localVarQueryParams.Add("sfixed64Value", parameterToString(sfixed64Value, ""))
	localVarQueryParams.Add("sint32Value", parameterToString(sint32Value, ""))
	localVarQueryParams.Add("sint64Value", parameterToString(sint64Value, ""))
	localVarQueryParams.Add("repeatedStringValue", parameterToString(repeatedStringValue, "multi"))
	localVarQueryParams.Add("oneofEmpty", parameterToString(oneofEmpty, ""))
	localVarQueryParams.Add("oneofString", parameterToString(oneofString, ""))
	localVarQueryParams.Add("mapValue", parameterToString(mapValue, ""))
	localVarQueryParams.Add("mappedStringValue", parameterToString(mappedStringValue, ""))
	localVarQueryParams.Add("mappedNestedValue", parameterToString(mappedNestedValue, ""))
	localVarQueryParams.Add("nonConventionalNameValue", parameterToString(nonConventionalNameValue, ""))
	localVarQueryParams.Add("timestampValue", parameterToString(timestampValue, ""))
	localVarQueryParams.Add("repeatedEnumValue", parameterToString(repeatedEnumValue, "multi"))
	localVarQueryParams.Add("repeatedEnumAnnotation", parameterToString(repeatedEnumAnnotation, "multi"))
	localVarQueryParams.Add("enumValueAnnotation", parameterToString(enumValueAnnotation, ""))
	localVarQueryParams.Add("repeatedStringAnnotation", parameterToString(repeatedStringAnnotation, "multi"))
	localVarQueryParams.Add("nestedAnnotation.name", parameterToString(nestedAnnotationName, ""))
	localVarQueryParams.Add("nestedAnnotation.amount", parameterToString(nestedAnnotationAmount, ""))
	localVarQueryParams.Add("nestedAnnotation.ok", parameterToString(nestedAnnotationOk, ""))
	localVarQueryParams.Add("int64OverrideType", parameterToString(int64OverrideType, ""))
	localVarQueryParams.Add("requiredStringViaFieldBehaviorAnnotation", parameterToString(requiredStringViaFieldBehaviorAnnotation, ""))
	localVarQueryParams.Add("outputOnlyStringViaFieldBehaviorAnnotation", parameterToString(outputOnlyStringViaFieldBehaviorAnnotation, ""))
	if localVarOptionals != nil && localVarOptionals.OptionalStringValue.IsSet() {
		localVarQueryParams.Add("optionalStringValue", parameterToString(localVarOptionals.OptionalStringValue.Value(), ""))
	}
	localVarQueryParams.Add("productId", parameterToString(productId, "multi"))
	localVarQueryParams.Add("optionalStringField", parameterToString(optionalStringField, ""))
	localVarQueryParams.Add("requiredStringField1", parameterToString(requiredStringField1, ""))
	localVarQueryParams.Add("requiredStringField2", parameterToString(requiredStringField2, ""))
	localVarQueryParams.Add("required_field_behavior_json_name_custom", parameterToString(requiredFieldBehaviorJsonNameCustom, ""))
	localVarQueryParams.Add("required_field_schema_json_name_custom", parameterToString(requiredFieldSchemaJsonNameCustom, ""))
	localVarQueryParams.Add("trailingOnly", parameterToString(trailingOnly, ""))
	localVarQueryParams.Add("trailingOnlyDot", parameterToString(trailingOnlyDot, ""))
	localVarQueryParams.Add("trailingBoth", parameterToString(trailingBoth, ""))
	localVarQueryParams.Add("trailingMultiline", parameterToString(trailingMultiline, ""))
	localVarQueryParams.Add("uuids", parameterToString(uuids, "multi"))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ExamplepbABitOfEverything
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return interface{}
*/
func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceErrorWithDetails(ctx context.Context) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v2/example/errorwithdetails"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuidName
 * @param singleNestedName name is nested field.
 * @param singleNestedAmount
 * @param singleNestedOk DeepEnum description.   - FALSE: FALSE is false.  - TRUE: TRUE is true.
 * @param floatValue Float value field
 * @param doubleValue
 * @param int64Value
 * @param uint64Value
 * @param int32Value
 * @param fixed64Value
 * @param fixed32Value
 * @param boolValue
 * @param stringValue
 * @param bytesValue
 * @param uint32Value
 * @param enumValue  - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param pathEnumValue
 * @param nestedPathEnumValue
 * @param sfixed32Value
 * @param sfixed64Value
 * @param sint32Value
 * @param sint64Value
 * @param repeatedStringValue
 * @param oneofEmpty
 * @param oneofString
 * @param mapValue map of numeric enum
 * @param mappedStringValue Map of string title  Map of string description.
 * @param mappedNestedValue
 * @param nonConventionalNameValue
 * @param timestampValue
 * @param repeatedEnumValue repeated enum value. it is comma-separated in query   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param repeatedEnumAnnotation Repeated numeric enum title  Repeated numeric enum description.   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param enumValueAnnotation Numeric enum title  Numeric enum description.   - ZERO: ZERO means 0  - ONE: ONE means 1
 * @param repeatedStringAnnotation Repeated string title  Repeated string description.
 * @param nestedAnnotationName name is nested field.
 * @param nestedAnnotationAmount
 * @param nestedAnnotationOk DeepEnum description.   - FALSE: FALSE is false.  - TRUE: TRUE is true.
 * @param int64OverrideType
 * @param requiredStringViaFieldBehaviorAnnotation mark a field as required in Open API definition
 * @param outputOnlyStringViaFieldBehaviorAnnotation mark a field as readonly in Open API definition
 * @param productId Test openapiv2 generation of repeated fields  Only digits are allowed.
 * @param optionalStringField Test openapiv2 generation of required fields with annotation and jsonschema to reproduce
 * @param requiredStringField1
 * @param requiredStringField2
 * @param requiredFieldBehaviorJsonNameCustom Test openapiv2 handling of required json_name fields
 * @param requiredFieldSchemaJsonNameCustom
 * @param trailingOnly Trailing only
 * @param trailingOnlyDot Trailing only dot.
 * @param trailingBoth Leading both  Trailing both.
 * @param trailingMultiline Leading multiline  This is an example of a multi-line comment.  Trailing multiline.
 * @param uuids Specify a custom format of repeated field items
 * @param optional nil or *ABitOfEverythingServiceExistsOpts - Optional Parameters:
     * @param "OptionalStringValue" (optional.String) -

@return interface{}
*/

type ABitOfEverythingServiceExistsOpts struct {
	OptionalStringValue optional.String
}

func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceExists(ctx context.Context, uuidName string, singleNestedName string, singleNestedAmount int64, singleNestedOk string, floatValue float32, doubleValue float64, int64Value string, uint64Value string, int32Value int32, fixed64Value string, fixed32Value int64, boolValue bool, stringValue string, bytesValue string, uint32Value int64, enumValue string, pathEnumValue string, nestedPathEnumValue string, sfixed32Value int32, sfixed64Value string, sint32Value int32, sint64Value string, repeatedStringValue []string, oneofEmpty map[string]string, oneofString string, mapValue interface{}, mappedStringValue string, mappedNestedValue interface{}, nonConventionalNameValue string, timestampValue time.Time, repeatedEnumValue []string, repeatedEnumAnnotation []string, enumValueAnnotation string, repeatedStringAnnotation []string, nestedAnnotationName string, nestedAnnotationAmount int64, nestedAnnotationOk string, int64OverrideType int64, requiredStringViaFieldBehaviorAnnotation string, outputOnlyStringViaFieldBehaviorAnnotation string, productId []string, optionalStringField string, requiredStringField1 string, requiredStringField2 string, requiredFieldBehaviorJsonNameCustom string, requiredFieldSchemaJsonNameCustom string, trailingOnly string, trailingOnlyDot string, trailingBoth string, trailingMultiline string, uuids []string, localVarOptionals *ABitOfEverythingServiceExistsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Head")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/example/a_bit_of_everything/{uuidName}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuidName"+"}", fmt.Sprintf("%v", uuidName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("singleNested.name", parameterToString(singleNestedName, ""))
	localVarQueryParams.Add("singleNested.amount", parameterToString(singleNestedAmount, ""))
	localVarQueryParams.Add("singleNested.ok", parameterToString(singleNestedOk, ""))
	localVarQueryParams.Add("floatValue", parameterToString(floatValue, ""))
	localVarQueryParams.Add("doubleValue", parameterToString(doubleValue, ""))
	localVarQueryParams.Add("int64Value", parameterToString(int64Value, ""))
	localVarQueryParams.Add("uint64Value", parameterToString(uint64Value, ""))
	localVarQueryParams.Add("int32Value", parameterToString(int32Value, ""))
	localVarQueryParams.Add("fixed64Value", parameterToString(fixed64Value, ""))
	localVarQueryParams.Add("fixed32Value", parameterToString(fixed32Value, ""))
	localVarQueryParams.Add("boolValue", parameterToString(boolValue, ""))
	localVarQueryParams.Add("stringValue", parameterToString(stringValue, ""))
	localVarQueryParams.Add("bytesValue", parameterToString(bytesValue, ""))
	localVarQueryParams.Add("uint32Value", parameterToString(uint32Value, ""))
	localVarQueryParams.Add("enumValue", parameterToString(enumValue, ""))
	localVarQueryParams.Add("pathEnumValue", parameterToString(pathEnumValue, ""))
	localVarQueryParams.Add("nestedPathEnumValue", parameterToString(nestedPathEnumValue, ""))
	localVarQueryParams.Add("sfixed32Value", parameterToString(sfixed32Value, ""))
	localVarQueryParams.Add("sfixed64Value", parameterToString(sfixed64Value, ""))
	localVarQueryParams.Add("sint32Value", parameterToString(sint32Value, ""))
	localVarQueryParams.Add("sint64Value", parameterToString(sint64Value, ""))
	localVarQueryParams.Add("repeatedStringValue", parameterToString(repeatedStringValue, "multi"))
	localVarQueryParams.Add("oneofEmpty", parameterToString(oneofEmpty, ""))
	localVarQueryParams.Add("oneofString", parameterToString(oneofString, ""))
	localVarQueryParams.Add("mapValue", parameterToString(mapValue, ""))
	localVarQueryParams.Add("mappedStringValue", parameterToString(mappedStringValue, ""))
	localVarQueryParams.Add("mappedNestedValue", parameterToString(mappedNestedValue, ""))
	localVarQueryParams.Add("nonConventionalNameValue", parameterToString(nonConventionalNameValue, ""))
	localVarQueryParams.Add("timestampValue", parameterToString(timestampValue, ""))
	localVarQueryParams.Add("repeatedEnumValue", parameterToString(repeatedEnumValue, "multi"))
	localVarQueryParams.Add("repeatedEnumAnnotation", parameterToString(repeatedEnumAnnotation, "multi"))
	localVarQueryParams.Add("enumValueAnnotation", parameterToString(enumValueAnnotation, ""))
	localVarQueryParams.Add("repeatedStringAnnotation", parameterToString(repeatedStringAnnotation, "multi"))
	localVarQueryParams.Add("nestedAnnotation.name", parameterToString(nestedAnnotationName, ""))
	localVarQueryParams.Add("nestedAnnotation.amount", parameterToString(nestedAnnotationAmount, ""))
	localVarQueryParams.Add("nestedAnnotation.ok", parameterToString(nestedAnnotationOk, ""))
	localVarQueryParams.Add("int64OverrideType", parameterToString(int64OverrideType, ""))
	localVarQueryParams.Add("requiredStringViaFieldBehaviorAnnotation", parameterToString(requiredStringViaFieldBehaviorAnnotation, ""))
	localVarQueryParams.Add("outputOnlyStringViaFieldBehaviorAnnotation", parameterToString(outputOnlyStringViaFieldBehaviorAnnotation, ""))
	if localVarOptionals != nil && localVarOptionals.OptionalStringValue.IsSet() {
		localVarQueryParams.Add("optionalStringValue", parameterToString(localVarOptionals.OptionalStringValue.Value(), ""))
	}
	localVarQueryParams.Add("productId", parameterToString(productId, "multi"))
	localVarQueryParams.Add("optionalStringField", parameterToString(optionalStringField, ""))
	localVarQueryParams.Add("requiredStringField1", parameterToString(requiredStringField1, ""))
	localVarQueryParams.Add("requiredStringField2", parameterToString(requiredStringField2, ""))
	localVarQueryParams.Add("required_field_behavior_json_name_custom", parameterToString(requiredFieldBehaviorJsonNameCustom, ""))
	localVarQueryParams.Add("required_field_schema_json_name_custom", parameterToString(requiredFieldSchemaJsonNameCustom, ""))
	localVarQueryParams.Add("trailingOnly", parameterToString(trailingOnly, ""))
	localVarQueryParams.Add("trailingOnlyDot", parameterToString(trailingOnlyDot, ""))
	localVarQueryParams.Add("trailingBoth", parameterToString(trailingBoth, ""))
	localVarQueryParams.Add("trailingMultiline", parameterToString(trailingMultiline, ""))
	localVarQueryParams.Add("uuids", parameterToString(uuids, "multi"))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param id
  - @param data

@return interface{}
*/
func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceGetMessageWithBody(ctx context.Context, id string, data ExamplepbBody) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v2/example/withbody/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &data
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param pathRepeatedFloatValue repeated values. they are comma-separated in path
  - @param pathRepeatedDoubleValue
  - @param pathRepeatedInt64Value
  - @param pathRepeatedUint64Value
  - @param pathRepeatedInt32Value
  - @param pathRepeatedFixed64Value
  - @param pathRepeatedFixed32Value
  - @param pathRepeatedBoolValue
  - @param pathRepeatedStringValue
  - @param pathRepeatedBytesValue
  - @param pathRepeatedUint32Value
  - @param pathRepeatedEnumValue
  - @param pathRepeatedSfixed32Value
  - @param pathRepeatedSfixed64Value
  - @param pathRepeatedSint32Value
  - @param pathRepeatedSint64Value

@return ExamplepbABitOfEverythingRepeated
*/
func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceGetRepeatedQuery(ctx context.Context, pathRepeatedFloatValue []float32, pathRepeatedDoubleValue []float64, pathRepeatedInt64Value []string, pathRepeatedUint64Value []string, pathRepeatedInt32Value []int32, pathRepeatedFixed64Value []string, pathRepeatedFixed32Value []int64, pathRepeatedBoolValue []bool, pathRepeatedStringValue []string, pathRepeatedBytesValue []string, pathRepeatedUint32Value []int64, pathRepeatedEnumValue []string, pathRepeatedSfixed32Value []int32, pathRepeatedSfixed64Value []string, pathRepeatedSint32Value []int32, pathRepeatedSint64Value []string) (ExamplepbABitOfEverythingRepeated, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ExamplepbABitOfEverythingRepeated
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/example/a_bit_of_everything_repeated/{pathRepeatedFloatValue}/{pathRepeatedDoubleValue}/{pathRepeatedInt64Value}/{pathRepeatedUint64Value}/{pathRepeatedInt32Value}/{pathRepeatedFixed64Value}/{pathRepeatedFixed32Value}/{pathRepeatedBoolValue}/{pathRepeatedStringValue}/{pathRepeatedBytesValue}/{pathRepeatedUint32Value}/{pathRepeatedEnumValue}/{pathRepeatedSfixed32Value}/{pathRepeatedSfixed64Value}/{pathRepeatedSint32Value}/{pathRepeatedSint64Value}"
	localVarPath = strings.Replace(localVarPath, "{"+"pathRepeatedFloatValue"+"}", fmt.Sprintf("%v", pathRepeatedFloatValue), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pathRepeatedDoubleValue"+"}", fmt.Sprintf("%v", pathRepeatedDoubleValue), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pathRepeatedInt64Value"+"}", fmt.Sprintf("%v", pathRepeatedInt64Value), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pathRepeatedUint64Value"+"}", fmt.Sprintf("%v", pathRepeatedUint64Value), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pathRepeatedInt32Value"+"}", fmt.Sprintf("%v", pathRepeatedInt32Value), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pathRepeatedFixed64Value"+"}", fmt.Sprintf("%v", pathRepeatedFixed64Value), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pathRepeatedFixed32Value"+"}", fmt.Sprintf("%v", pathRepeatedFixed32Value), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pathRepeatedBoolValue"+"}", fmt.Sprintf("%v", pathRepeatedBoolValue), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pathRepeatedStringValue"+"}", fmt.Sprintf("%v", pathRepeatedStringValue), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pathRepeatedBytesValue"+"}", fmt.Sprintf("%v", pathRepeatedBytesValue), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pathRepeatedUint32Value"+"}", fmt.Sprintf("%v", pathRepeatedUint32Value), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pathRepeatedEnumValue"+"}", fmt.Sprintf("%v", pathRepeatedEnumValue), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pathRepeatedSfixed32Value"+"}", fmt.Sprintf("%v", pathRepeatedSfixed32Value), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pathRepeatedSfixed64Value"+"}", fmt.Sprintf("%v", pathRepeatedSfixed64Value), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pathRepeatedSint32Value"+"}", fmt.Sprintf("%v", pathRepeatedSint32Value), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pathRepeatedSint64Value"+"}", fmt.Sprintf("%v", pathRepeatedSint64Value), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if len(pathRepeatedFloatValue) < 1 {
		return localVarReturnValue, nil, reportError("pathRepeatedFloatValue must have at least 1 elements")
	}
	if len(pathRepeatedDoubleValue) < 1 {
		return localVarReturnValue, nil, reportError("pathRepeatedDoubleValue must have at least 1 elements")
	}
	if len(pathRepeatedInt64Value) < 1 {
		return localVarReturnValue, nil, reportError("pathRepeatedInt64Value must have at least 1 elements")
	}
	if len(pathRepeatedUint64Value) < 1 {
		return localVarReturnValue, nil, reportError("pathRepeatedUint64Value must have at least 1 elements")
	}
	if len(pathRepeatedInt32Value) < 1 {
		return localVarReturnValue, nil, reportError("pathRepeatedInt32Value must have at least 1 elements")
	}
	if len(pathRepeatedFixed64Value) < 1 {
		return localVarReturnValue, nil, reportError("pathRepeatedFixed64Value must have at least 1 elements")
	}
	if len(pathRepeatedFixed32Value) < 1 {
		return localVarReturnValue, nil, reportError("pathRepeatedFixed32Value must have at least 1 elements")
	}
	if len(pathRepeatedBoolValue) < 1 {
		return localVarReturnValue, nil, reportError("pathRepeatedBoolValue must have at least 1 elements")
	}
	if len(pathRepeatedStringValue) < 1 {
		return localVarReturnValue, nil, reportError("pathRepeatedStringValue must have at least 1 elements")
	}
	if len(pathRepeatedBytesValue) < 1 {
		return localVarReturnValue, nil, reportError("pathRepeatedBytesValue must have at least 1 elements")
	}
	if len(pathRepeatedUint32Value) < 1 {
		return localVarReturnValue, nil, reportError("pathRepeatedUint32Value must have at least 1 elements")
	}
	if len(pathRepeatedEnumValue) < 1 {
		return localVarReturnValue, nil, reportError("pathRepeatedEnumValue must have at least 1 elements")
	}
	if len(pathRepeatedSfixed32Value) < 1 {
		return localVarReturnValue, nil, reportError("pathRepeatedSfixed32Value must have at least 1 elements")
	}
	if len(pathRepeatedSfixed64Value) < 1 {
		return localVarReturnValue, nil, reportError("pathRepeatedSfixed64Value must have at least 1 elements")
	}
	if len(pathRepeatedSint32Value) < 1 {
		return localVarReturnValue, nil, reportError("pathRepeatedSint32Value must have at least 1 elements")
	}
	if len(pathRepeatedSint64Value) < 1 {
		return localVarReturnValue, nil, reportError("pathRepeatedSint64Value must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ExamplepbABitOfEverythingRepeated
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param uuid

@return ExamplepbABitOfEverything
*/
func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceLookup(ctx context.Context, uuid string) (ExamplepbABitOfEverything, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ExamplepbABitOfEverything
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/example/a_bit_of_everything/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ExamplepbABitOfEverything
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param exampleEnum

@return interface{}
*/
func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServicePostOneofEnum(ctx context.Context, exampleEnum OneofenumExampleEnum) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/example/oneofenum"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &exampleEnum
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body

@return interface{}
*/
func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServicePostRequiredMessageType(ctx context.Context, body ExamplepbRequiredMessageTypeRequest) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/example/requiredmessagetype"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param name
  - @param body

@return interface{}
*/
func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServicePostWithEmptyBody(ctx context.Context, name string, body ABitOfEverythingServicePostWithEmptyBodyBody) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v2/example/postwithemptybody/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return interface{}
*/
func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceTimeout(ctx context.Context) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v2/example/timeout"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param uuidName
  - @param body

@return interface{}
*/
func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceUpdate(ctx context.Context, uuidName string, body ExamplepbABitOfEverythingServiceUpdateBody) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Put")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/example/a_bit_of_everything/{uuidName}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuidName"+"}", fmt.Sprintf("%v", uuidName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param bookName The resource name of the book.  Format: &#x60;publishers/{publisher}/books/{book}&#x60;  Example: &#x60;publishers/1257894000000000000/books/my-book&#x60;
  - @param book The book to update.  The book&#39;s &#x60;name&#x60; field is used to identify the book to be updated. Format: publishers/{publisher}/books/{book}
  - @param allowMissing If set to true, and the book is not found, a new book will be created. In this situation, &#x60;update_mask&#x60; is ignored.

@return ExamplepbBook
*/
func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceUpdateBook(ctx context.Context, bookName string, book TheBookToUpdate_, allowMissing bool) (ExamplepbBook, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Patch")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ExamplepbBook
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/{book.name}"
	localVarPath = strings.Replace(localVarPath, "{"+"book.name"+"}", fmt.Sprintf("%v", bookName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("allowMissing", parameterToString(allowMissing, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &book
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ExamplepbBook
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param uuidName
  - @param abe A bit of everything  Intentionally complicated message type to cover many features of Protobuf.
  - @param updateMask The paths to update.

@return interface{}
*/
func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceUpdateV2(ctx context.Context, uuidName string, abe ABitOfEverything, updateMask string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Put")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v2/example/a_bit_of_everything/{uuidName}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuidName"+"}", fmt.Sprintf("%v", uuidName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("updateMask", parameterToString(updateMask, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &abe
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param uuidName
  - @param abe A bit of everything  Intentionally complicated message type to cover many features of Protobuf.

@return interface{}
*/
func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceUpdateV22(ctx context.Context, uuidName string, abe ABitOfEverything1) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Patch")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v2/example/a_bit_of_everything/{uuidName}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuidName"+"}", fmt.Sprintf("%v", uuidName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &abe
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ABitOfEverythingServiceApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param uuidName
  - @param body

@return interface{}
*/
func (a *ABitOfEverythingServiceApiService) ABitOfEverythingServiceUpdateV23(ctx context.Context, uuidName string, body ABitOfEverythingServiceUpdateV2Body) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Patch")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v2a/example/a_bit_of_everything/{uuidName}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuidName"+"}", fmt.Sprintf("%v", uuidName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-foo-mime"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/x-foo-mime"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 418 {
			var v ExamplepbNumericEnum
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v ExamplepbErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 0 {
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
